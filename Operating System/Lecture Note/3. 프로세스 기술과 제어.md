# 3.1 프로세스란?

운영체제는 응용 수행을 관리함에 있어 다음을 지원한다.

- 여러 애플리케이션들이 자원들을 이용할 수 있게 한다.
- 여러 애플리케이션들 사이에 물리적인 처리기를 교체 할당하여 모든 애플리케이션들이 병행 진행되는 것처럼 보이게 한다.
- 처리기와 입출력 장치들이 효율적으로 사용될 수 있게 한다.
- 모든 현대 운영체제에서는, 한 응용의 수행이 하나 이상의 프로세스들의 존재에 대응하는 모델에 의존한다.

### 프로세스 및 프로세스 제어블록

- 프로세스의 정의
    - 수행 중인 프로그램
    - 컴퓨터 상에 수행 중인 프로그램의 인스턴스
    - 처리기에 할당되어 수행될 수 있는 개체(entity)
    - 명령들의 순차 수행, 현재 상태, 연계된 시스템 자원들의 집합 등에 의해 특징지어지는 활성화 단위(a unit of activity)
- 프로세스의 필수적인 요소 2가지
    - **프로그램 코드**: 동일 프로그램을 수행하는 서로 다른 프로세스들이 공유할 수 있는 부분
    - **데이터의 집합**: 프로그램 코드와 연계된 데이터의 집합
    - 처리기가 프로그램 코드를 수행한다고 가정하면, 그 수행 중인 개체가 프로세스이다.
- 프로그램이 수행 중 특정 시점에, 프로세스가 유일하게 식별될 수 있는 요소들
    - 식별자: 각 프로세스를 다른 모든 프로세스로부터 구별하게 해주는 유일한 식별자
    - 상태: 프로세스가 현재 수행 중이면, 그 프로세스는 수행(running) 상태에 있음
    - 우선순위
    - 프로그램 카운터: 프로그램에서 다음에 수행될 명령어의 주소
    - 메모리 포인터: 프로세스와 연계된 프로그램 코드 및 데이터, 다른 프로세스들과 함께 공유되는 메모리 블록들에 대한 포인터 포함
    - 문맥 데이터(context data): 프로세스가 수행 중일 때, 처리기의 레지스터에 존재하는 데이터
    - 입출력 상태 정보
    - 어카운팅 정보(accounting information, 과금 정보): 사용된 처리기 시간 및 클록 시간, 시간 제한, 계정 번호 등 포함될 수 있음.
    - ⇒ 위의 정보는 전형적으로 프로세스 제어 블록이라는 자료구조에 저장됨.
        - 프로세스 제어블록: 수행 프로세스를 인터럽트한 후 나중에 그 인터럽트가 발생되지 않은 것처럼 프로세스 수행을 재개할 수 있도록 충분한 정보 유지. 운영체제가 다수의 프로세스 지원 및 멀티프로세싱을 제공할 수 있게 해주는 주요 도구
- 프로세스는 **프로그램 코드** 및 관련된 **데이터**, 그리고 **프로세스 제어블록**으로 구성된다고 볼 수 있음.

## 3.2 프로세스 상태

- 디스패처(dispatcher): 처리기를 한 프로세스로부터 다른 프로세스로 교체(switch)해주는 프로그램
    - 다음 번 프로세스를 고르는 것
- 2-state 프로세스 모델
    - 수행(Running, 실행): 실행하고 있는 순간
    - 비수행(Not Running, 비실행)
    - 새로운 프로세스를 생성할 때, 그 프로세스에 대한 프로세스 제어블록을 생성하고 비수행 상태로 초기화시킴. 이제 프로세스는 존재하게 되며 운영체제에게 알려져, 자신이 수행될 기회를 기다림.
    - 현재 수행 중인 프로세스가 인터럽트 당하게 되면 디스패처가 수행할 새로운 프로세스를 선택하고, 인터럽트 당한 이전 프로세스는 수행 → 비수행 상태로 전이됨. 다른 프로세스들 중 하나가 수행 상태로 바뀜.

    ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/489fb534-be48-4161-b80a-aff8d024a8ed)


    - PCB(Process Control Block)
    - 여기에 있는 단일 큐의 각 항목은 특정 프로세스의 PCB를 가리키는 포인터이다.
    - 큐잉 다이어그램
        - 수행 중에 인터럽트 당한 프로세스는 대기 프로세스들의 큐로 옮겨진다.
        - 그러나 만일 프로세스의 수행이 완료되었거나 도중에 취소되었다면, 프로세스는 폐기(discard)되어 시스템을 떠난다.
        - 어떤 경우든 디스패처는 다음에 수행할 프로세스를 큐에서 선택한다.

### 프로세스의 생성(creation)과 종료(termination)

- 프로세스 생성: 주소공간 생성 및 자료구조 구축
    - fork(Linux) or CreateProcess(Windows)
    - 부모 프로세스 vs 자식 프로세스: 하나의 프로세스가 다른 프로세스를 생성할 때, 전자를 부모 프로세스, 후자를 자식 프로세스라 함.
    - 프로세스 생성 이유
      ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/6b034b11-4ecb-496c-aeb8-966d903cb339)

     
        
- 프로세스 종료
    - 프로세스 종료 이유
         ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/40c375a4-21f9-4ab8-892a-3b5922f48540)
        ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/cc9f79e0-130b-4173-a311-cc946166b68d)

- 5-state process model
    - 수행(Running)
    - 준비(Ready)
    - 블록(Blocked)
    - 생성(New)
    - 종료(Exit)
![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/a6285d79-f792-4294-82f9-de2147d6be45)

        
    - 상태 전이를 일으키는 이벤트들의 종류
        - Null → 생성(New): 생성(create)
        - 생성 → 준비(Ready): 승인(admit)
        - 준비 → 수행(Running): 디스패치(dispatch)
        - 수행 → 종료(Exit): 종료 (완료)
        - 수행 → 준비: 선점 (시간 만료 또는 높은 우선순위)
            - 수행되고 있던 프로세스가 최대 처리기 시간을 모두 사용했을 경우(시간 정책)
        - 수행 → 블록(Blocked): 사건 대기(sleep)
            - 프로세스가 자원을 요구했는데 기다려야 하는 경우
        - 블록 → 준비: 사건 발생 (wake up)
            - 블록 상태에 있는 프로세스는 자신이 기다리고 있던 이벤트가 발생하게 되면 준비 상태로 전이됨.
        - 준비 → 종료
        - 블록 → 종료
    
    ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/ecf63eb8-6212-421e-afaa-9409e434e32a)


### 보류된 프로세스(Suspended Process)

- Swapping
    - 스와핑: 프로세스의 일부나 전체를 주기억장치로부터 디스크로 옮겨놓는 방법
    - 스왑-인(swap-in) 및 스왑-아웃(swap-out)
    - 스왑-아웃: 종료되지 않은 프로세스의 전체 이미지 (또는 일부 이미지)를 주기억장치로부터 ‘스왑공간’으로 이동시키는 것
    - 스왑-인: 스왑-아웃된 프로세스의 전체 이미지를 스왑 공간으로부터 주기억장치로 적재하는 것
    - 스와핑은 입출력 연산 ⇒ 문제 악화시킬 수 O. but, 디스크 입출력은 시스템에서 가장 빠른 입출력 작업이기 때문에 일반적으로 스와핑을 성능을 향상시킬 것임.
    - 스와핑의 필요성
        - 더 많은 가용 메모리(free memory)를 확보하기 위해
        - 주기억장치에 준비 상태의 프로세스가 없을 때
- 4가지 상태
    - 준비(Ready): 프로세스가 주기억장치에 있고 수행될 수 있다.
    - 블록(Blocked): 프로세스가 주기억장치에 있고 사건을 기다리고 있다.
    - 블록/보류(Blocked/Suspend): 프로세스가 보조기억장치에 있고, 사건을 기다리고 있다.
    - 준비/보류(Ready/Suspend): 프로세스가 보조기억장치에 있지만, 주기억장치에 적재되면 즉시 수행될 수 있다.
- Blocked → Blocked/Suspend: 보류, 즉 스왑-아웃
- Blocked/Suspend → Ready/Suspend: 보류 상태에서 깨움
- Ready/Suspend → Ready: 활성화(activate), 즉 스왑-인
- Ready → Ready/Suspend: 보류, 즉 스왑-아웃

## 3.3 프로세스 기술

### OS 제어 구조(control structures)

- 각 프로세스 및 자원의 현재 상태에 대한 정보 유지
- 보통, OS가 관리하는 각 개체를 위한 테이블이 구성됨
    - 메모리 테이블
    - I/O 테이블 = 입출력 테이블
    - 파일 테이블
    - 프로세스 테이블
- 메모리 테이블
    - 프로세들에 할당된 주기억장치 정보
    - 프로세스들에 할당된 2차 메모리(디스크) 정보
    - 공유 메모리 영역에 접근하기 위한 보호 속성(Protection attributes)
    - 가상 메모리(virtual memory)를 관리하는 필요한 정보
- I/O 테이블
    - I/O 연산에 필요한 정보 유지: 사용 중인지 아닌지
    - I/O 전송에서 소스 또는 목적지 주소로 사용될 주기억장치에서의 위치
- 파일 테이블
    - 2차 메모리에서의 위치
    - 현재 상태, 속성
    - 파일 시스템을 관리하는 데 필요한 정보
- 프로세스 테이블
    - 프로세스의 위치 정보
    - 각 프로세스들의 프로세스 제어 블록(PCB) 목록을 갖고 있다.

### 프로세스 제어 구조

- 프로세스 속성
    - 프로세스를 제어하기 위해 OS가 사용하는 정보
    - 프로세스 제어 블록 = 속성들의 집합
        - PCB = 태스크 제어블록 = 프로세스 디스크립터
- 프로세스 이미지 (process image)
    - 프로그램 (code or text)
    - 데이터
    - 스택
    - PCB: 프로세스 식별, 처리기 상태 정보, 프로세스 제어 정보
- PCB: 프로세스 제어 블록
    - OS에 의해 관리
    - 다수의 프로세스를 지원하고 다중처리를 제공할 수 있게 지원하는 주요 자료구조
    
   ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/5692726d-5260-441c-a511-b614a069ee22)

    - 프로세스 식별: 숫자로 된 식별자 (PID, PPID, UID,…)
        - OS가 각 프로세스에게 할당하는 유일한 식별자. 주 프로세스 테이블에 대한 인덱스
    - 처리기 상태 정보: 처리기 레지스터의 내용들로 구성
        - User-Visible Registers(사용자가 사용 가능한 레지스터), 제어 및 상태 레지스터, 스택 포인터
        - 프로그램 상태 워드(PSW) : 상태 정보가 저장디는 레지스터. 대개 조건 코드 및 기타 상태 정보 저장
    - 프로세스 제어 정보
        - 스케줄링 및 상태 정보
        - 다른 프로세스들 간의 포인터 정보
        - 프로세스 간 통신
        - 프로세스 권한
        - 메모리 관리
        - 자원 소유권 및 이용률
    

## 3.4 프로세스 제어

### 수행 모드(Modes of Execution) _ 처리기 실행 모드

- 사용자 모드(user mode): 권한을 덜 가진 모드
- 시스템 모드(system mode), 제어 모드(control mode), 커널 모드(kernel mode): 더 높은 권한을 가진 모드
- 두 가지 모드를 사용하는 이유: 사용자 프로그램의 간섭으로부터 운영체제 및 프로세스 제어블록과 같은 주요 운영체제 테이블을 보호할 필요가 있기 때문

### 프로세스 생성

1. 새로운 프로세스에 유일한 프로세스 식별자 할당
2. 프로세스에 공간 할당
3. 프로세스 제어블록 초기화
4. 적절한 연결(linkage) 설정
5. 다른 자료구조 생성 또는 확장

### 프로세스 교환(Process Switching)

- 프로세스 교환 시점
    - OS가 현재 수행 중인 프로세스로부터 제어를 넘겨받을 때마다, 프로세스 교환 발생
    - 시스템 인터럽트: 인터럽트, 트랩(trap)
        - 인터럽트: 외부에서 유발되는 사건에 의해 발생
            - 클럭 인터럽트, 입출력 인터럽트, 메모리 폴트
        - 트랩: 현재 수행되고 있는 프로세스에서 생성되는 오류나 예외 조건 때문에 발생
            - 트랩 발생 시 관련 오류 또는 예외 조건이 치명적인지 아닌지를 판단함.
                - 치명적 → 현재 수행되고 있는 프로세스 종료, 프로세스 교환
                - 치명적X → 복구 프로시저 수행 or 사용자에게 통보 등 서로 다르게 동작
                - → 수퍼바이저 호출
- 모드 전환(Mode Switching)
    - 프로세스로부터의 서비스 호출 → 인터럽트 발생
    - 대기하고 있는 인터럽트가 있다면, 처리기는 다음 작업 수행
        1. 프로그램 카운터의 값을 인터럽트 핸들러 프로그램의 시작 주소로 설정시킴
        2. 사용자 모드를 커널 모드로 전환시켜서 인터럽트 처리 코드가 특권 명령어를 수행할 수 있도록 함.
- 프로세스 상태 변경 (change)
    1. 프로그램 카운터 및 다른 레지스터들을 포함하여 처리기의 문맥을 저장
    2. 현재 수행 상태에 있는 프로세스
    3. 그 PCB를 준비큐, 블록큐, 또는 준비/보류큐 중의 하나에 삽입
    4. 실행할 다른 프로세스를 선택
    5. 새로 선택된 프로세스의 PCB를 갱신
    6. 메모리 관리 자료구조를 갱신
    7. 선택된 프로세스의 문맥을 복원

![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/b31fa07e-aaa9-4baf-af1a-d60a57f51ee7)

## 3.5 운영체제의 수행

### OS 실행(execution)

- 비 프로세스 커널 (Non-process Kernel, 분리된 커널)
    - OS 코드가 특권 모드(privileged mode)에서 분리된 개체(seperate entity)로 실행
- 사용자 프로세스 내에서 실행
    - 사용자 프로세스 문맥 내에 OS 소프트웨어가 유지
    - 프로세스가 OS 코드를 실행 중일 때는 특권 모드를 가짐
- 프로세스 기반 OS(Process-Based OS)
    - 시스템 프로세스들의 집합으로 OS를 구현
    - 다중 처리기 또는 다중 컴퓨터 환경에 유용

![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/2c92ccfd-27ad-4d77-829d-bfc9070ed895)

![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/b543a1dc-f195-409a-a999-f50aab8110cf)

## 3.6 UNIX SVR4의 프로세스 관리

UNIX는 시스템 프로세스와 사용자 프로세스를 사용한다.

- 시스템 프로세스: 커널 모드에서 수행. 메모리 할당과 프로세스 스와핑 등과 같은 시스템 관리 작업 수행
- 사용자 프로세스: 상황에 따라 사용자 모드와 커널 모드에서 동작함. 시스템 호출을 수행할 때, 또는 예외나 인터럽트가 발생되었을 때 커널 모드로 진입
- 프로세스 기술

![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/debbd379-b0df-45e2-bc27-6556f8adb64f)

- 프로세스 테이블
    
   ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/4b39fca0-6268-4b5f-b663-72158f29b048)
