# 7.1 메모리 관리 요구조건

## 메모리 관리 (memory management)

- 다중 프로그래밍 시스템에서 다수의 프로세스를 수용하기 위해 주기억장치를 동적으로 분할하는 작업
- 메모리 관리 요구조건
    - 재배치(Relocation): swap in&out
    - 보호(Protection): 한 프로세스가 차지하고 있는 주소공간을 다른 프로세스가 차지X
    - 공유(Sharing)
    - 논리적 구성 (Logical organization): 코드영역, 데이터 영역, PCB
    - 물리적 구성 (Physical organization): swap 장치와 주메모리가 올리지 않은 미적재 영역을 참조하려고 할 때

### 1) 재배치(Relocation)

- 다수의 프로세스들이 스왑인&스왑아웃 시 다른 주소 공간으로의 프로세스 재배치 필요
- 재배치를 고려한 프로세스 주소 지정 요구조건
    
    ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/e42a062a-9c73-4723-975c-eebfd997b290)


### 2) 보호(Protection)

- 다른 프로세스들의 간섭으로부터 보호
- 메모리 참조 검사: 실행 중 해당 프로세스에 할당된 메모리 공간만 참조되었는지 확인 필요
- 메모리 보호: 처리기(하드웨어)적인 검사 요구

### 3) 공유(Sharing)

- 주기억장치의 같은 부분을 접근하려는 여러 개의 프로세스들을 융통성 있게 허용
- 필수적인 보호 기능을 침해하지 않는 범위에서 제한된 접근을 통한 공유

### 4) 논리적인 구성

- 일반적인 프로그램: 모듈 단위 구성
- 운영체제 및 하드웨어의 모듈 단위 처리 시 이점
    - 모듈의 작성과 컴파일이 독립적으로 이루어짐
    - 비교적 적은 추가비용(overhead)로 모듈마다 서로 다른 보호 등급 적용 가능
    - 프로세스 간 모듈 공유 기법 제공
- 대표적인 메모리 관리 기술: 세그먼테이션(Segmentation)

### 5) 물리적인 구성

- 주기억 장치와 보조 기억 장치 사이의 물리적 정보 흐름 책임자: 시스템(응용이 알아서X)
- 응용에게 주메모리와 스왑 공간 간 데이터 이동 책임을 전가하면 안되는 이유
    - 사용 가능한 주기억장치 용량 < 프로그램 및 데이터 인 경우 처리(overlay 기법 이용)
    - 다중 프로그래밍 환경: 사용 가능한 공간의 양과 위치 정보 파악 가능

<br>
<br>

## 메모리 관리 기법

### 1) 연속 메모리 관리 (contiguous memory management)

- 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야만 함.
    - 단일 연속 메모리 관리
    - 고정 분할 기법 (fixed partitioning): 고정된 사이즈씩. 한번 나눈 메모리 분할은 바꿀 수 없음.
        - 장) 구현 간단: OS에 오버헤드가 거의 X
        - 단) 내부단편화로 인한 비효율적인 사용 ⇒ 최대 활성 프로세스의 수가 고정됨
    - 동적 분할 기법 (dynamic partitioning): 연속된 메모리에 크기각 다른 메모리 공간 할당
        - 장) 내부단편화X, 주기억장치를 보다 효율적으로 사용할 수 O
        - 단) 외부단편화 해결을 위한 메모리 집약(compaction)이 요구됨. ⇒ 처리기 효율이 나빠짐.

### 2) 불연속 메모리 관리 (non-contigous memory management)

- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
    - 고정 크기: 페이징 (paging), 주기억장치는 균등 사이즈의 프레임으로 나뉨 → 각 프로세스는 균등 페이지들로 나뉨
        - 장) 외부 단편화 없음
        - 단) 적은 양의 내부 단편화 생김
    - 가변 크기: 세그먼테이션(segmentation), 각 프로세스는 여러 세그먼트들로 나뉨.
        - 장) 내부 단편화 없음, 메모리 사용 효율 개선, 동적분할에 비해서 오버헤드 적음
        - 단) 외부 단편화

⇒ 연속(고정<동적) < 불연속(고정>가변)

### 3) 불연속 메모리 + 가상 메모리 관리 기법

- 가상 메모리 페이징 (virtual memory paging)
    - : 단순 페이징과 비교해서 프로세스의 페이지 전부를 로드시킬 필요X 필요한 페이지가 있으면 후에 자동적으로 불러들어짐.
    - 강점) 외부 단편화 X, 다중 프로그래밍 정도가 높고 가상 주소 공간이 큼
    - 약점) 복잡한 메모리 관리의 오버헤드
- 가상 메모리 세그먼테이션 (virtual memory segmentation)
    - : 단순 세그먼테이션과 비교해서 필요하지 않은 세그먼트들을 로드하지 않음. 필요한 게르먼트가 있으면 나중에 자동적으로 불려들어짐.
    - 강점) 내부 단편화 X, 높은 수준의 다중 프로그래밍, 큰 가상 주소공간, 보호&공유 지원
    - 약점) 복잡한 메모리 관리의 오버헤드

<br>
<br>

# 7.2 메모리 분할 (memory partitioning)

## 1) 고정 분할

- 고정된 경계를 가지는 메모리 영역으로 구분
- 균등 분할과 비균등 분할
- 균등 분할의 문제점
    - ‘프로그램 크기 > 파티션 크기’ 일 가능성: overlay 기법 이용해야 함.
    - 주기억 장치 이용률 저조
    - 내부단편화 발생 (internal fragmentation)
- 배치 알고리즘
    - 균등 분할: 사용 가능한 파티션에 적재 or 기존 프로세스 스왑 아웃
    - 비균등 분할: 최적 파티션에 할당(내부 단편화 최소화)
    - <그림 7.3> 비균등 고정 분할에서의 메모리 배정
        
        ![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/cee958a9-a594-4b46-81c3-cd8ac9083421)

- 고정 분할 기법의 문제점
    - 파티션 수에 의해 활성화된 프로세스 수 제한
    - 크기가 작은 작업일수록 파티션 공간을 비효율적으로 사용
    - 내부 단편화 발생

### 2) 동적 분할

- 파티션 크기와 개수가 가변적
- 프로세스가 요구한 크기만큼의 메모리만 할당(응용이 필요로 하는 만큼만 할당)
- 단점) 외부 단편화 발생
- 메모리 집약 필요
- 배치 알고리즘
    - 최적 적합 (best-fit): 남는 공간이 가장 적은 것
    - 최초 적합 (first-fit): 남는 게 나오면 바로 넣음
    - 순환 적합 (next-fit)
    - 최악 적합 (worst-fit)
- 교체 알고리즘
    - 메모리 부족 시 스왑아웃 시킬 프로세스를 선택

<br>
<br>

### Buddy System

- 고정 분할, 동적 분할 결점을 보완한 절충안
- 메모리 블록 크기
    - 2^k, L ≤ K ≤ U
    - 2^L: 할당된 가장 작은 크기의 블록
    - 2^U: 할당된 가장 큰 크기의 블록

![image](https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/b75eccd9-e1fb-4bb5-b44d-5695be585421)

- 버디 시스템의 활용
    - 병렬 프로그램의 할당과 해제: 변렬 시스템의 응용 프로그램

<br>

### 재배치 (Relocation)

: 재배치 지원을 위해 사용되는 주소 유형

- Swap out 되었다가 in되었을 때 다른 주소 공간으로 되면 재배치 필요
- 논리 주소: 현재 데이터가 적재된 메모리와는 독립적인 메모리 위치에 대한 참조
- 상대 주소: 논리 주소의 한 예로 어떤 절대 위치로부터 얼마만큼 떨어져 있는 위치에 대한 참조(물리 주소로 매핑)
- 물리 주소

<br>
<br>

# 7.3 페이징 (paging)

- 페이지(page): 작은 고정 사이즈의 프로세스 조각(가상 주소(논리주소)로 지칭)
- 프레임(frame): 페이지와 크기가 같은 주기억장치 메모리 조각
- 페이지 테이블: 프로세스의 각 페이지에 해당하는 프레임 위치 관리
- 외부 단편화 발생 안 함
- 내부 단편화는 각 프로세스의 마지막 페이지에서만 발생
- 단순 페이징은 고정 분할 방법과 유사함. 다른 점은 다음과 같음
    - 파티션의 크기가 보다 작음
    - 한 프로그램이 하나 이상의 파티션을 차지할 수 있음.
    - 이 파티션들이 반드시 연속일 필요는 없음.
- 이 페이징 기법이 편리하게 사용되려면, 페이지 크기와 프레임의 크기를 2의 거듭제곱이 되도록 해야 함. ⇒ 프로그램의 시작 위치로부터 상대 주소와 페이지 번호와 오프셋으로 표현되는 논리주소가 같음.
    - 논리 주소의 구조가 프로그래머, 어셈블러, 링커에게 투명함
        - 프로그램의 논리 주소(페이지 번호, 오프셋)는 상대 주소와 동일하기 때문
    - 수행 중에 동적 주소 변환을 담당할 하드웨어 기능을 구현하기가 비교적 쉬움
    

<br>
<br>


# 7.4 세그먼테이션 (segmentation)

- 비균등 크기의 세그먼트 이용
- 동적 분할과 유사(비균등 크기의 세그먼트를 사용하기 때문)
- 동적 분할과의 차이점
    - 비연속적인 한 개 이상의 파티션을 차지할 수 있음.
    - 이 파티션들이 연속적일 필요 없음
- 내부 단편화 X, 외부 단편화 초래 O(상대적으로 적은 편)
- 가장 불편한 점: 프로그래머가 세그먼트의 최대 크기를 알고 있어야 함.
- 비균등 세그먼트 사용 단점
    - 논리주소와 물리주소 간에 복잡한 관계 존재
