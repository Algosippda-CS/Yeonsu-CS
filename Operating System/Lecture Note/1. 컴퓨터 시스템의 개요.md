## 기본 구성요소

컴퓨터는 다음의 4가지 기본 구성요소로 이루어진다.

1. 처리기(프로세서, processor): 컴퓨터의 동작 제어 & 데이터 처리.
    - 처리기가 하나만 있는 경우에는 일반적으로 중앙처리장치(CPU)라고 부름.
    - 컴퓨터의 두뇌: 데이터 연산, 논리 연산(ALU), 제어(Control Unit)
    - x86, ARM, PPC, Sparc, Alpha, MIPS, SH4, XScale
2. 주기억장치(main memory): 데이터와 프로그램 저장(실메모리라고도 불림)
    - **휘발성(volatile)**
    - 메모리 셀: 메모리 내의 개별적인 저장 공간
    - 주기억장치는 실기억장치(real memory) 혹은 주메모리(primary memory)라고도 불림.
    - 저장장치(storage device): 비휘발성(non-volatile)
        - 디스크, CD-ROM, 플로피, Flash Memory(NOR, NAND 등)
3. 입출력 모듈(I/O module): 컴퓨터와 외부 환경 간의 데이터 이동을 담당
    - 외부 환경은 보조기억장치, 통신장비, 그리고 단말기를 포함한 외부 장치로 구성됨.
    - 입력 장치(input device): 키보드, 마우스, Key Pad, Touch Screen
    - 출력 장치(output device): 모니터, 프린터, LCD
4. 시스템 버스(System bus): 처리기, 주기억장치, 입출력 모듈 간의 통신 제공
    1. 통신 장치: 모뎀, 이더넷, IrDA, CDMA, Bluetooth
    
<img width="608" alt="스크린샷 2023-11-07 오전 10 17 48" src="https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/fbbac4fb-dfc3-46c2-ac32-8ce5e5c18817">
컴퓨터 구성 요소 (취상위 수준 관점)


<br/>

### 처리기 레지스터

- 메모리 주소 레지스터(MAR): 다음에 읽거나 기록할 메모리 내 주소를 명시
- 메모리 버퍼 레지스터(MBR): 메모리에 기록되거나 메모리로부터 읽힐 데이터 저장
- 입출력 버퍼 레지스터(IOBR): 입출력 모듈과 처리기 간의 데이터 교환을 위해 사용됨.

- 메모리 모듈: 일련 번호로 주소가 부여된 장소들의 집합
    - 각 장소에는 이진수가 저장되어 있는데 이러한 이진수는 명령어 또는 데이터로 해석될 수 있음.

<br/>


## 마이크로 프로세서의 발전

- 마이크로 프로세서
    - 단일 칩에 하나의 프로세서를 집적
    - 가장 빠른 범용 프로세서
    - 멀티 프로세서로 발전: 하나의 칩에 코어라고 불리는 여러 개의 프로세서 포함
- GPU(Graphical Processing Unit)
    - 단일명령 다중 데이터(Single Instruction Multiple Data) 처리
    - 고급 그래픽 렌더링 뿐만 아니라 범용 수치처리에서도 사용
- DSP(Digital Signal Processing)
    - 오디오와 비디오 같은 스트림형 시그널 처리를 위한 프로세서
- SoC(System on a Chip)
    - CPU와 캐시뿐 아니라 DSP, GPU, I/O 디바이스, 주기억장치 등이 하나의 칩에 내장

   <br/>
   
### 주요 처리기 레지스터

- 제어 및 상태 레지스터(Control and status registers)
    - 처리기의 작동을 제어하기 위해 사용
    - 프로그램의 실행을 제어하기 위한 특권 모드의 운영체제 루틴에 의해 사용됨
    - **PC(Program Counter)**: 반입할 **명령어의 주소** 포함
    - **IR(Instruction Register)**: **수행될 명령어**
        - 최근에 반입된 명령어 포함
        - PC에 있는 주소에 가서 그 instruction을 가져옴.
    - **PSW(Program Status Word)**
        - 인터럽트 enable/disable
        - 슈퍼바이저(특권모드)/사용자 모드
        - 조건 코드(condition codes) 또는 플래그
            - Positive result, Nagative result, Zero, Overflow

명령어 실행(instruction cycle)

1. 처리기가 메모리로부터 명령어 읽음(반입, fetch)
2. 처리기가 각 명령어 실행(수행, execution)
<img width="556" alt="스크린샷 2023-11-07 오전 10 48 52" src="https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/0f5e41a9-7aeb-4911-bec6-011cc93706f5">


- 처리기는 메모리(RAM)로부터 명령어 반입
- PC가 다음에 반입할 명령어의 주소를 저장함.
- PC는 매 명령어 반입 후 (자동) 증가됨.
    - PC + 1 ⇒ 다음 연산자를 가리킴
- 반입된 명령어는 명령어 레지스터에 적재(store)
- instruction
    - 처리기-메모리
    - 처리기-I/O
    - 데이터 처리: 데이터에 산술 또는 논리 연산
    - 제어: 실행 순서의 변경
<img width="514" alt="스크린샷 2023-11-07 오전 11 01 48" src="https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/523eb9cd-62e5-4ff6-a8ae-5b87a15e91eb">


<br/>

## 인터럽트(interrupt)

- 인터럽트는 처리기의 정상적인 흐름을 방해
- 대부분의 I/O 디바이스는 처리기보다 느림
    - 처리기는 디바이스가 작업을 완료할 때까지 **기다려야 함. ⇒ 처리기의 성능 저하 유발**
        - 이를 위해 디바이스가 작업이 완료되면 처리기에게 인터럽트를 걸 수 있도록 허용
    - Blocking I/O의 문제점: CPU가 멈춘다.(Block)
- 인터럽트와 프로그램 제어 흐름
  <img width="648" alt="스크린샷 2023-11-07 오후 1 33 24" src="https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/3e030f68-bfff-4095-abfe-ca3d1e1445f3">

- 인터럽트 단계
    - 처리기가 인터럽트를 검사
    - 인터럽트가 발생한 경우
        - 프로그램의 실행 보류 (현재 실행 보류, 그 시점을 기억해둠)
        - 인터럽트-처리 루틴 실행
    - 인터럽트 처리 루틴
        - 특정 I/O 디바이스를 서비스하기 위한 프로그램
        - 일반적으로 운영체제 시스템에 포함됨
        - 인터럽트 처리를 위한 오버헤드가 존재하나, 입출력 연산이 완료되기를 기다리며 낭비하는 시간에 비해 상대적으로 짦음.
- 간단한 인터럽트 처리
    <img width="384" alt="스크린샷 2023-11-07 오후 1 36 01" src="https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/0a9098bc-0b7d-4ab2-b81b-2a3fd08695b3">

- 순차적 인터럽트 처리
    - 하나의 인터럽트가 처리 중에는 다른 인터럽트를 불능화
        - 상대적인 우선순위나 시간 긴급도(time-critical)를 고려하지 않음.
        - 바람직하지는 않은 방법
- 다중 인터럽트
    - 인터럽트 간의 우선 순위 지정: 장치마다 우선순위가 지정됨.
    - ex) 프린터 인터럽트 서비스 루틴 → 통신 인터럽트 서비스 루틴 → 디스크 인터럽트 서비스 루틴

인터럽트로 인해 다중 프로그래밍이 가능함.

- 처리기는 실행 가능한 하나 이상의 프로그램을 보유함.
- 프로그램이 실행되는 순서는 프로그램의 상대적인 우선 순위와 입출력 대기 여부에 따라 달라짐
- 인터럽트 처리 루틴이 실행을 마치면, 인터럽트가 발생한 당시에 수행 중이던 프로그램으로 제어가 돌아가지 않을 수 있음. (다른 프로세스로 돌아갈 수도 있다.)


<br/>

## 메모리 계층 구조
<img width="322" alt="스크린샷 2023-11-07 오후 1 42 32" src="https://github.com/Algosippda-CS/Yeonsu-CS/assets/82032452/257e95c3-5ba0-424c-998e-400961a997a0">

- 접근 시간이 빠르면 비트 당 비용이 높아짐
- 용량이 크면 비트 당 저장 비용이 낮아짐 & 접근 시간이 길어짐
- 계층 구조를 따라 내려갈수록
    - 비트 당 비용 감소
    - 용량 증가
    - 접근 속도 증가
    - 처리기가 메모리를 접근하는 횟수 감소

<br/>

### 2차 메모리

- 보조 메모리
- 외부 저장 장치
- 비휘발성(non-volatile)
- 프로그램과 데이터 파일을 저장하기 위해 사용 (주로 일반적인 사용자 데이터 저장)

<br/>

### 캐시(Cache) 메모리

- 캐싱(Caching):
    - 빠른 저장 장치에 정보를 **복사**해 놓는 기법
    - 고속의 메모리에 최근에 접근한 데이터를 저장
    - 캐시 관리 정책(cache management policy) 필요
    - 캐싱은 메모리 계층 구조에 또 다른 레벨을 도입하는데, 하나 이상의 레벨에 동시에 저장된 데이터 사이에 내용이 일치해야 한다. 즉, 여러 프로세스가 동시에 쓰면 안 된다.
- 캐시 원칙
    - 주 메모리의 한 영역의 복사본을 가지고 있음.
    - 처리기는 먼저 캐시를 참조하고, 캐시에 없으면 필요한 정보가 저장된 메모리 블록이 캐시로 읽힌다.
    - 참조 지역성 때문에 향후 참조죌 데이터는 캐시에 존재할 가능성이 높다.
        - 참조 지역성: 한번 참조되면 다음에 또 참조될 가능성이 높다.
- 캐시 메모리
    - 운영체제에게 보이지 않고, 하드웨어적으로 처리됨.
    - 메모리 접근 속도를 향상시킴..
    - 프로세서 속도 > 메모리 속도
    - 참조 지역성(locality of reference)의 원리 이용
- 디스크 캐시(Disk Cache, Buffer Cache: UNIX)
    - 메인 메모리의 일부가 디스크에 저장된 데이터의 일부를 일시적으로 저장하기 위해 사용됨.
    - 디스크 쓰기는 클러스터 되는 경향이 있음.
    - 어떤 디스크 블록들은 또 접근될 수 있는데, 이 경우 디스크가 아닌 **버퍼 캐시로부터** 데이터를 읽어오므로 **접근 속도가 빠름.**

<br/>

### 📌 참조 지역성 원리 (Locality of Reference)

- 프로그램이 실행되는 도중에 처리기에 의해서 **접근되는 메모리 영역이 집중화**(cluster)하는 경향이 있다.
- 장기적으로 이러한 클러스터는 변경될 수 있으나, 짧은 시간에 처리기는 메모리 접근을 고정된 수의 클러스터에 한정되는 경향이 있다.
- 명령어(instruction): 반복문(iterative loop), 서브루틴(subroutines)
- 데이터(data): 테이블(tables), 배열(arrayse)
- 적중률(Hit ration: H): 메모리 접근 중 데이터가 빠른 메모리에 존재할 비율로 정의됨.
    - ex)
        - T1은 레벨1 메모리(ex. 캐시메모리) 접근 시간으로 정의됨.
        - T2은 레벨2 메모리(ex. 메인메모리) 접근 시간으로 정의됨.

<br/>

### 캐시 원칙

- 캐시의 크기: 작은 크기의 캐시도 성능에 큰 영향을 미친다.
- 블록의 크기: 캐시와 메인 메모리 사이에 교환되는 데이터의 단위
    - 블록의 크기가 클수록 높은 적중률을 보임.(단, 새로 반입된 데이터를 참조할 확률이 캐시에서 방출된 데이터를 참조할 확률보다 적어질 때까지)
- 매핑 함수: 블록이 캐시의 어느 위치에 저장될지를 결정
- 교체 알고리즘: 교체될 블록을 선정
    - Least-recently-used (LRU) 알고리즘: 최근에 참조되지 않은 것은 가까운 미래에도 참조되지 않을 가능성이 높다.
- 쓰기 정책: 어느 시점에 메모리를 쓸 것인가를 결정
    - 블록이 갱신될 때마다 쓴다.
    - 블록이 교체될 때마다 쓴다.
        - 쓰기 연산을 최소로 한다.
        - 메인 메모리의 데이터가 최신이 아님.

<br/>

### 입출력 통신 기술

- **프로그램된 입출력 (Programmed I/O)**
    - 처리기는 입출력 연산이 끝날 때까지 입출력 모듈의 상태를 주기적으로 체크함.
    - 처리기가 아니라 입출력 모듈이 수행함.
    - 인터럽트가 없음.
- **인터럽트 구동 입출력 (Interrupt-driven I/O)**
    - 입출력 모듈이 데이터를 교환할 준비가 되면 처리기에게 인터럽트를 보냄.
    - 처리기는 프로그램의 실행 문맥을 저장하고 인터럽트 처리 루틴을 실행함.
    - 기다릴 필요 X
    - 읽거나 쓸 데이터가 처리기를 통해 이동되기 때문에 처리기 시간을 낭비함.
- **직접 메모리 접근 (DMA: Direct Memory Access)**
    - 디바이스 제어기는 처리기의 간섭 없이 주기억장치와 입출력 모듈의 버퍼 사이에 데이터 블록을 직접 전송함. ⇒ 데이터 전송 성능을 높임
    - 처리기는 명령어를 실행하는데 전혀 지장을 받지 않음.
    - DMA 모듈은 데이터 전송을 위해 I/O 제어기를 이용하고, I/O 작업이 끝나면 처리기에게 인터럽트를 통해 알린다.
    - 많은 양의 입출력 연산을 수행하는 시스템의 I/O 성능을 높여준다.
    
<br/>
<br/>

## 멀티 프로세서와 멀티 코어 구조

전통적으로 컴퓨터 프로세서는 순차적으로 한번에 하나씩 명령을 수행했음.

병렬성 제공 방법: 대칭형 멀티 프로세서, 멀티코어, 클러스터

<br/>

### 대칭적 다중 처리

: 두 개 이상의 유사한 수행 능력을 갖는 프로세서로 구성되어 있고, 이들 프로세서는 버스나 다른 내부 연결 방식에 의해 상호 연결된, 주기억장치와 I/O 장치를 공유한다. 

⇒ 따라서 각 프로세서들의 메모리 접근 시간은 거의 동일

<종류>

- Single Instruction Single Data (SISD) stream
    - 단일 명령어 다중 데이터
    - 단일 처리기가 한 메모리에 저장된 데이터를 처리하기 위해 단일 명령 스트림을 수행
- Single Instruction Multiple Data (SIMD) stream
    - 각 (동일) 명령이 서로 다른 데이터 집합에 대해 서로 다른 처리기에 의해 수행됨.
    - 벡터 및 배열 처리기, Pentium 처리기의 superscalar 구조
- Multiple Instruction Single Data (MISD) stream
    - (같은) 일련의 데이터가 처리기들의 집합에 전송되고, 각 처리기는 서로 다른 명령을 수행함.
    - 지금까지 구현된 적 없음.
- Multiple Instruction Multiple Data (MIMD) stream
    - 다중 명령어 다중 데이터
    - 다수의 처리기가 서로 다른 데이터 집합에 대해 서로 다른 일련의 병령어들을 동시에 수행함.

<br/>

<특징>

- 각 프로세서들의 메모리 접근 시간이 거의 동일함.
- 동일한 장치에 이르는 경로들을 제공하는 채널이 동일하거나 달라도 모든 프로세서는 I/O 장치 접근을 공유함.
- 모든 처리기는 동일한 기능을 수행할 수 있음. (대칭형)
- 시스템은 프로세서들과 작업(job), 태스크(task), 파일, 그리고 데이터 요소 수준에서 프로그램들 간의 상호작용을 제공하는 하나의 통합된 운영체제에 의해 제어

<br/>

<장점>

- 성능: 병렬 처리 → 성능 향상 가능
- 가용성: 모든 처리기들이 동일한 기능을 수행할 수 있기 때문에 하나가 고장나도 시스템은 다소 성능이 떨어진 상태에서 지속적으로 동작할 수 있음.
- 점진적 확장: 사용자는 성능 향상을 위해 필요할 때마다 처리기를 추가로 설치할 수 있음.
- 크기 조정 (scaling): 벤더들은 시스템을 구성하는 처리기의 수에 따라 가격과 성능이 다른 다양한 제품을 공급할 수 있음.

<br/>

<SMP를 위한 OS 설계 시 고려 사항>

- 목적: 사용자가 다중프로그래밍 단일 처리기 시스템과 동일한 관점을 가질 수 있게 자원 관리
- 동시적 병행 프로세스 또는 스레드: 재진입 커널 코드, 분리된 커널 자료 구조
- SMP를 위한 스케줄링: 전역 큐/지역 큐, 집단 스케줄링, 친화성
- 동기화: 상호배제, 사건 순서화
- 메모리 관리: 다중포트 메모리(multiport memory)
- 신뢰성 및 결함 허용(fulat tolerance): 이주(migration)
