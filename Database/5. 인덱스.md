# 📌 Section 5. 인덱스

## 5.1 인덱스의 필요성

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.

인덱스 설정 시 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있음.

<br/>

## 5.2 B-트리

인덱스는 보통 B-tree 라는 자료 구조로 이루어져 있다.

이는 루트 노드, 리프 노드, 브랜치 노드(루트와 리프 노드 사이에 있는 노드)로 나뉜다.

- 트리 탐색 : 맨 위 루트노드 → 브랜치 노드 → 리프 노드
    - 마지막 리프 노드에 도달해서 찾은 값이 가리키는 데이터 포인터를 통해 결과값 반환
- 인덱스가 효율적인 이유:
    - 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조
    - 트리 깊이의 대수 확장성

<br/>

## 5.3 인덱스 만드는 방법

### MySQL

- 클러스터형 인덱스
    - 테이블당 하나 설정 가능
    - `primary key` 옵션으로 기본키로 만들면 생성 가능
    - 기본키로 만들지 않고 `unique not null` 옵션을 붙이면 클러스터형 인덱스로 만들 수 있음.
- 세컨더리 인덱스
    - `create index` 명령어 기반으로 만들면 생성 가능
    - 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 게 더 성능이 좋음.
    - 보조 인덱스
        - 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스

### MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨.
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스 설정 가능

<br/>

## 5.4 인덱스 최적화 기법

인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같다.

여기서는 MongoDB를 기반으로 설명한다.

이를 기반으로 다른 데이터베이스에 웬만큼 적용할 수 있다.

### 1. 인덱스는 비용이다.

- 인덱스는 두 번 탐색하도록 강요한다.
    - 인덱스 리스트 → 컬렉션 순으로 탐색하기 때문.
    - 관련 읽기 비용 소모됨
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 함.
    - B-tree의 높이를 균형 있게 조절하는 비용 소모
    - 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용 소모
- 따라서 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 좋지 않음.
- 컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용은 비효율적

### 2. 항상 테스팅하라.

- 인덱스 최적화 기법은 서비스 특징에 따라 달라짐
    - 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문
- 항상 테스팅하는 것이 중요!
- `explain()` 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 함.

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.

보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.

`같음 → 정렬 → 다중 값→ 카디널리티` 순으로 생성해야 한다.

1. 어떤 값과 같음을 비교하는 `==` 이나 `equal` 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정
2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 `>` 이거나 `<` 등 많을 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정
4. 카디널리티: 유티크한 값의 정도 ⇒ 카디널리티가 높은 순서를 기반으로 인덱스 생성.
